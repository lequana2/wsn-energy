//
// Generated file, do not edit! Created by opp_msgc 4.4 from packet/packet.msg.
//

#ifndef _PACKET_M_H_
#define _PACKET_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0404
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include "packet_len.h"
// }}


namespace wsn_energy {

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum MESSAGE_KIND{
 * 	COMMAND = 4; 
 * 	RESULT  = 1; 
 * 	DATA    = 2; 
 * };
 * </pre>
 */
enum MESSAGE_KIND {
    COMMAND = 4,
    RESULT = 1,
    DATA = 2
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum SPECIAL_EVENT{
 * 	NODE_STARTUP  = 0; 
 * 	OUT_OF_ENERGY = 1; 
 * 	NODE_DESTRUCT = 2; 
 * };
 * </pre>
 */
enum SPECIAL_EVENT {
    NODE_STARTUP = 0,
    OUT_OF_ENERGY = 1,
    NODE_DESTRUCT = 2
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum COMMAND_FROM_APP{
 * 	APP_WORKING_FLAG = 0; 
 * 	APP_SENSING_FLAG = 1; 
 * 	APP_ENVIRON_FLAG = 2; 
 * 	
 * 	RPL_CONSTRUCT = 3; 
 * 	RPL_SET_UP	  = 4; 
 * };
 * </pre>
 */
enum COMMAND_FROM_APP {
    APP_WORKING_FLAG = 0,
    APP_SENSING_FLAG = 1,
    APP_ENVIRON_FLAG = 2,
    RPL_CONSTRUCT = 3,
    RPL_SET_UP = 4
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum COMMAND_FROM_NET{
 *     NET_TIMER_DIO          = 1;  
 *     NET_TIMER_DIS          = 2;  
 * };
 * </pre>
 */
enum COMMAND_FROM_NET {
    NET_TIMER_DIO = 1,
    NET_TIMER_DIS = 2
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum RESULT_FROM_NET{
 * 	NET_DIO_SENT          = 69; 
 * }
 * </pre>
 */
enum RESULT_FROM_NET {
    NET_DIO_SENT = 69
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum IP_PACKET_TYPE{
 * 	NET_DATA        	  = 1;  
 * 	NET_ICMP_RPL		  = 2;  
 * 	
 * 	NET_ICMP_DIO    	  = 3;	
 * 	NET_ICMP_DIS    	  = 4;	
 * };
 * </pre>
 */
enum IP_PACKET_TYPE {
    NET_DATA = 1,
    NET_ICMP_RPL = 2,
    NET_ICMP_DIO = 3,
    NET_ICMP_DIS = 4
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum COMMAND_FROM_MAC{
 * 	CHANNEL_CCA_REQUEST = 70; 
 * 	MAC_SEND_BUFFER     = 71; 
 * 	MAC_CHECK_BUFFER    = 72; 
 * };
 * </pre>
 */
enum COMMAND_FROM_MAC {
    CHANNEL_CCA_REQUEST = 70,
    MAC_SEND_BUFFER = 71,
    MAC_CHECK_BUFFER = 72
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum RESULT_FROM_MAC{
 *     MAC_SEND_DEAD_NEIGHBOR = 5;
 *     
 * 
 * 
 * 
 * 
 * };
 * </pre>
 */
enum RESULT_FROM_MAC {
    MAC_SEND_DEAD_NEIGHBOR = 5
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum COMMAND_FROM_RDC{
 * 	RDC_SEND   = 30; 
 * 	RDC_LISTEN = 31; 
 * 	RDC_IDLE   = 32; 
 * 	
 * 	RDC_WAIT_FOR_ACK = 34; 
 * };
 * </pre>
 */
enum COMMAND_FROM_RDC {
    RDC_SEND = 30,
    RDC_LISTEN = 31,
    RDC_IDLE = 32,
    RDC_WAIT_FOR_ACK = 34
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum RESULT_FROM_RDC{
 * 	RDC_SEND_OK     = 0; 
 * 	RDC_SEND_NO_ACK = 1; 
 * 	RDC_SEND_FATAL  = 2; 
 * 	RDC_SEND_COL	= 3; 
 * };
 * </pre>
 */
enum RESULT_FROM_RDC {
    RDC_SEND_OK = 0,
    RDC_SEND_NO_ACK = 1,
    RDC_SEND_FATAL = 2,
    RDC_SEND_COL = 3
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum COMMAND_FROM_PHY{
 * 	PHY_BEGIN_CCA       = 10; 
 * 	PHY_END_CCA         = 11; 
 * 	
 *  	PHY_SWITCH_TRANSMIT	= 12; 
 *  	PHY_SWITCH_LISTEN	= 13; 
 *  	PHY_SWITCH_IDLE     = 14; 
 *  	
 *  	PHY_BEGIN_TRANSMIT  = 15; 
 * 	PHY_END_TRANSMIT	= 16; 
 * 
 *  	PHY_LISTENING    = 17; 
 *  	
 *  	PHY_IDLING  	 = 18; 
 * };
 * </pre>
 */
enum COMMAND_FROM_PHY {
    PHY_BEGIN_CCA = 10,
    PHY_END_CCA = 11,
    PHY_SWITCH_TRANSMIT = 12,
    PHY_SWITCH_LISTEN = 13,
    PHY_SWITCH_IDLE = 14,
    PHY_BEGIN_TRANSMIT = 15,
    PHY_END_TRANSMIT = 16,
    PHY_LISTENING = 17,
    PHY_IDLING = 18
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum RESULT_FROM_PHY{
 * 	CHANNEL_CLEAR   	= 10; 
 * 	CHANNEL_BUSY    	= 11; 
 * 	
 * 	PHY_TX_OK		 = 12; 
 * 	PHY_TX_ERR 		 = 13; 
 * 	PHY_BUSY		 = 14; 
 * 	
 * 	PHY_RECV_OK          = 15; 
 * 	PHY_RECV_CORRUPTED   = 16; 
 * 	PHY_RECV_INCOMPLETED = 17; 
 * };
 * </pre>
 */
enum RESULT_FROM_PHY {
    CHANNEL_CLEAR = 10,
    CHANNEL_BUSY = 11,
    PHY_TX_OK = 12,
    PHY_TX_ERR = 13,
    PHY_BUSY = 14,
    PHY_RECV_OK = 15,
    PHY_RECV_CORRUPTED = 16,
    PHY_RECV_INCOMPLETED = 17
};

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet Command{
 * 	int note;
 * }
 * </pre>
 */
class Command : public ::cPacket
{
  protected:
    int note_var;

  private:
    void copy(const Command& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Command&);

  public:
    Command(const char *name=NULL, int kind=0);
    Command(const Command& other);
    virtual ~Command();
    Command& operator=(const Command& other);
    virtual Command *dup() const {return new Command(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getNote() const;
    virtual void setNote(int note);
};

inline void doPacking(cCommBuffer *b, Command& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Command& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet Result{
 * 	int note;
 * }
 * </pre>
 */
class Result : public ::cPacket
{
  protected:
    int note_var;

  private:
    void copy(const Result& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Result&);

  public:
    Result(const char *name=NULL, int kind=0);
    Result(const Result& other);
    virtual ~Result();
    Result& operator=(const Result& other);
    virtual Result *dup() const {return new Result(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getNote() const;
    virtual void setNote(int note);
};

inline void doPacking(cCommBuffer *b, Result& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Result& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet Raw{
 * }
 * </pre>
 */
class Raw : public ::cPacket
{
  protected:

  private:
    void copy(const Raw& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Raw&);

  public:
    Raw(const char *name=NULL, int kind=0);
    Raw(const Raw& other);
    virtual ~Raw();
    Raw& operator=(const Raw& other);
    virtual Raw *dup() const {return new Raw(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, Raw& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Raw& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet Frame{
 *     int numberTransmission = 0; 
 * 
 * 	int sequenceNumber;   
 * 	bool isACK; 		  
 * 
 * 	int senderMacAddress; 
 * 	int recverMacAddress; 
 * }
 * </pre>
 */
class Frame : public ::cPacket
{
  protected:
    int numberTransmission_var;
    int sequenceNumber_var;
    bool isACK_var;
    int senderMacAddress_var;
    int recverMacAddress_var;

  private:
    void copy(const Frame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Frame&);

  public:
    Frame(const char *name=NULL, int kind=0);
    Frame(const Frame& other);
    virtual ~Frame();
    Frame& operator=(const Frame& other);
    virtual Frame *dup() const {return new Frame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getNumberTransmission() const;
    virtual void setNumberTransmission(int numberTransmission);
    virtual int getSequenceNumber() const;
    virtual void setSequenceNumber(int sequenceNumber);
    virtual bool getIsACK() const;
    virtual void setIsACK(bool isACK);
    virtual int getSenderMacAddress() const;
    virtual void setSenderMacAddress(int senderMacAddress);
    virtual int getRecverMacAddress() const;
    virtual void setRecverMacAddress(int recverMacAddress);
};

inline void doPacking(cCommBuffer *b, Frame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Frame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet IpPacket{
 * 	int messageCode;	
 * 	int icmpCode;       
 * 
 *     int senderIpAddress; 
 *     int recverIpAddress; 
 * }
 * </pre>
 */
class IpPacket : public ::cPacket
{
  protected:
    int messageCode_var;
    int icmpCode_var;
    int senderIpAddress_var;
    int recverIpAddress_var;

  private:
    void copy(const IpPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IpPacket&);

  public:
    IpPacket(const char *name=NULL, int kind=0);
    IpPacket(const IpPacket& other);
    virtual ~IpPacket();
    IpPacket& operator=(const IpPacket& other);
    virtual IpPacket *dup() const {return new IpPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getMessageCode() const;
    virtual void setMessageCode(int messageCode);
    virtual int getIcmpCode() const;
    virtual void setIcmpCode(int icmpCode);
    virtual int getSenderIpAddress() const;
    virtual void setSenderIpAddress(int senderIpAddress);
    virtual int getRecverIpAddress() const;
    virtual void setRecverIpAddress(int recverIpAddress);
};

inline void doPacking(cCommBuffer *b, IpPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IpPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet DIO  extends IpPacket{
 * 	int dodagID; 
 * 	int version; 
 * 	
 * 	unsigned long rank; 
 * 	
 * 	double selfEnergy;   
 * }
 * </pre>
 */
class DIO : public ::wsn_energy::IpPacket
{
  protected:
    int dodagID_var;
    int version_var;
    unsigned long rank_var;
    double selfEnergy_var;

  private:
    void copy(const DIO& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DIO&);

  public:
    DIO(const char *name=NULL, int kind=0);
    DIO(const DIO& other);
    virtual ~DIO();
    DIO& operator=(const DIO& other);
    virtual DIO *dup() const {return new DIO(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getDodagID() const;
    virtual void setDodagID(int dodagID);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual unsigned long getRank() const;
    virtual void setRank(unsigned long rank);
    virtual double getSelfEnergy() const;
    virtual void setSelfEnergy(double selfEnergy);
};

inline void doPacking(cCommBuffer *b, DIO& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DIO& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet DIS  extends IpPacket{
 * }
 * </pre>
 */
class DIS : public ::wsn_energy::IpPacket
{
  protected:

  private:
    void copy(const DIS& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DIS&);

  public:
    DIS(const char *name=NULL, int kind=0);
    DIS(const DIS& other);
    virtual ~DIS();
    DIS& operator=(const DIS& other);
    virtual DIS *dup() const {return new DIS(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, DIS& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DIS& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet UdpPacket{
 *     int sourceIpAddress; 
 * 	int sinkIpAddress;   
 * }
 * </pre>
 */
class UdpPacket : public ::cPacket
{
  protected:
    int sourceIpAddress_var;
    int sinkIpAddress_var;

  private:
    void copy(const UdpPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpPacket&);

  public:
    UdpPacket(const char *name=NULL, int kind=0);
    UdpPacket(const UdpPacket& other);
    virtual ~UdpPacket();
    UdpPacket& operator=(const UdpPacket& other);
    virtual UdpPacket *dup() const {return new UdpPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSourceIpAddress() const;
    virtual void setSourceIpAddress(int sourceIpAddress);
    virtual int getSinkIpAddress() const;
    virtual void setSinkIpAddress(int sinkIpAddress);
};

inline void doPacking(cCommBuffer *b, UdpPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UdpPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet Data{
 *     double time;  
 *     
 * 	string value; 
 * }
 * </pre>
 */
class Data : public ::cPacket
{
  protected:
    double time_var;
    opp_string value_var;

  private:
    void copy(const Data& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Data&);

  public:
    Data(const char *name=NULL, int kind=0);
    Data(const Data& other);
    virtual ~Data();
    Data& operator=(const Data& other);
    virtual Data *dup() const {return new Data(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual double getTime() const;
    virtual void setTime(double time);
    virtual const char * getValue() const;
    virtual void setValue(const char * value);
};

inline void doPacking(cCommBuffer *b, Data& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Data& obj) {obj.parsimUnpack(b);}

}; // end namespace wsn_energy

#endif // _PACKET_M_H_

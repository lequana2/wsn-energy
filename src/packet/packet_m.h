//
// Generated file, do not edit! Created by opp_msgc 4.4 from packet/packet.msg.
//

#ifndef _PACKET_M_H_
#define _PACKET_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0404
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif


namespace wsn_energy {

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum MESSAGE_KIND{
 * 	DATA    = 2; 
 * 	COMMAND = 4; 
 * 	RESULT  = 1; 
 * };
 * </pre>
 */
enum MESSAGE_KIND {
    DATA = 2,
    COMMAND = 4,
    RESULT = 1
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum MANUAL_EVENT{
 * 	NODE_STARTUP  = 0; 
 * 	OUT_OF_ENERGY = 1; 
 * 	NODE_DESTRUCT = 2; 
 * };
 * </pre>
 */
enum MANUAL_EVENT {
    NODE_STARTUP = 0,
    OUT_OF_ENERGY = 1,
    NODE_DESTRUCT = 2
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum COMMAND_APP{
 * 	APP_ENVIRON_FLAG = 2; 
 * 	APP_SENSING_FLAG = 1; 
 * 	APP_WORKING_FLAG = 0; 
 * 	
 * 	RPL_SET_UP_DELAY = 4; 
 * };
 * </pre>
 */
enum COMMAND_APP {
    APP_ENVIRON_FLAG = 2,
    APP_SENSING_FLAG = 1,
    APP_WORKING_FLAG = 0,
    RPL_SET_UP_DELAY = 4
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum COMMAND_NET{
 *     NET_TIMER_DIO       = 1; 
 *     NET_TIMER_DIS       = 2; 
 * 	NET_CHECK_BUFFER    = 3; 
 * 
 * 	RPL_CONSTRUCT 	 	= 4; 
 * };
 * </pre>
 */
enum COMMAND_NET {
    NET_TIMER_DIO = 1,
    NET_TIMER_DIS = 2,
    NET_CHECK_BUFFER = 3,
    RPL_CONSTRUCT = 4
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum RESULT_NET{
 * 	NET_DIO_SENT	= 23; 
 * 	NET_DIS_SENT    = 24; 
 * }
 * </pre>
 */
enum RESULT_NET {
    NET_DIO_SENT = 23,
    NET_DIS_SENT = 24
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum IP_PACKET_NEXT_HEADER{
 *     NEXT_HEADER_UDP		= 0; 
 *     NEXT_HEADER_TCP		= 1; 
 *     NEXT_HEADER_ICMP	= 2; 
 * };
 * </pre>
 */
enum IP_PACKET_NEXT_HEADER {
    NEXT_HEADER_UDP = 0,
    NEXT_HEADER_TCP = 1,
    NEXT_HEADER_ICMP = 2
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum ICMP_TYPE{
 *     ICMP_RPL		= 0; 
 * }
 * </pre>
 */
enum ICMP_TYPE {
    ICMP_RPL = 0
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum ICMP_CODE{
 * 	RPL_DIO_CODE   	  = 0;	
 * 	RPL_DIS_CODE	  = 1;	
 * }
 * </pre>
 */
enum ICMP_CODE {
    RPL_DIO_CODE = 0,
    RPL_DIS_CODE = 1
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum COMMAND_MAC{
 * 	CHANNEL_CCA_REQUEST = 70; 
 * 	
 * 	MAC_BEGIN_SEND_FRAME = 73; 
 * 	MAC_END_SEND_FRAME   = 74; 
 * 	MAC_EXPIRE_IFS		 = 75; 
 * };
 * </pre>
 */
enum COMMAND_MAC {
    CHANNEL_CCA_REQUEST = 70,
    MAC_BEGIN_SEND_FRAME = 73,
    MAC_END_SEND_FRAME = 74,
    MAC_EXPIRE_IFS = 75
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum FRAME_TYPE{
 *     FRAME_BEACON  	= 35; 
 *     FRAME_COMMAND 	= 36; 
 * 	FRAME_DATA 		= 37; 
 * 	FRAME_ACK  		= 38; 
 * }
 * </pre>
 */
enum FRAME_TYPE {
    FRAME_BEACON = 35,
    FRAME_COMMAND = 36,
    FRAME_DATA = 37,
    FRAME_ACK = 38
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum RESULT_FROM_MAC{
 *     MAC_SEND_DEAD_NEIGHBOR = 5;
 * 	
 * 	MAC_FINISH_PHASE       = 29; 
 * 	MAC_SEND_END_TRANSMIT  = 28; 
 * };
 * </pre>
 */
enum RESULT_FROM_MAC {
    MAC_SEND_DEAD_NEIGHBOR = 5,
    MAC_FINISH_PHASE = 29,
    MAC_SEND_END_TRANSMIT = 28
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum COMMAND_RDC{
 * 	RDC_TRANSMIT = 30; 
 * 	RDC_LISTEN 	 = 31; 
 * 	RDC_IDLE     = 32; 
 * 	
 * 	RDC_WAIT_FOR_ACK  = 34; 
 * 	RDC_CHANNEL_CHECK = 35; 
 * };
 * </pre>
 */
enum COMMAND_RDC {
    RDC_TRANSMIT = 30,
    RDC_LISTEN = 31,
    RDC_IDLE = 32,
    RDC_WAIT_FOR_ACK = 34,
    RDC_CHANNEL_CHECK = 35
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum RESULT_RDC{
 * 	RDC_SEND_OK     = 0; 
 * 	RDC_SEND_NO_ACK = 1; 
 * 	RDC_SEND_FATAL  = 2; 
 * 	RDC_SEND_COL	= 3; 
 * };
 * </pre>
 */
enum RESULT_RDC {
    RDC_SEND_OK = 0,
    RDC_SEND_NO_ACK = 1,
    RDC_SEND_FATAL = 2,
    RDC_SEND_COL = 3
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum COMMAND_PHY{
 * 	PHY_BEGIN_CCA       = 10; 
 * 	PHY_END_CCA         = 11; 
 * 	
 *  	PHY_SWITCH_TRANSMIT	= 12; 
 *  	PHY_SWITCH_LISTEN	= 13; 
 *  	PHY_SWITCH_IDLE     = 14; 
 *  	
 *  	PHY_BEGIN_TRANSMIT  = 15; 
 * 	PHY_END_TRANSMIT	= 16; 
 * 
 *  	PHY_LISTENING    = 17; 
 *  	
 *  	PHY_IDLING  	 = 18; 
 * };
 * </pre>
 */
enum COMMAND_PHY {
    PHY_BEGIN_CCA = 10,
    PHY_END_CCA = 11,
    PHY_SWITCH_TRANSMIT = 12,
    PHY_SWITCH_LISTEN = 13,
    PHY_SWITCH_IDLE = 14,
    PHY_BEGIN_TRANSMIT = 15,
    PHY_END_TRANSMIT = 16,
    PHY_LISTENING = 17,
    PHY_IDLING = 18
};

/**
 * Enum generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum RESULT_PHY{
 * 	CHANNEL_CLEAR   	= 10; 
 * 	CHANNEL_BUSY    	= 11; 
 * 	
 * 	PHY_TX_OK		 = 12; 
 * 	PHY_TX_ERR 		 = 13; 
 * 	PHY_BUSY		 = 14; 
 * 	
 * 	PHY_RECV_OK          = 15; 
 * 	PHY_RECV_CORRUPTED   = 16; 
 * 	PHY_RECV_INCOMPLETED = 17; 
 * };
 * </pre>
 */
enum RESULT_PHY {
    CHANNEL_CLEAR = 10,
    CHANNEL_BUSY = 11,
    PHY_TX_OK = 12,
    PHY_TX_ERR = 13,
    PHY_BUSY = 14,
    PHY_RECV_OK = 15,
    PHY_RECV_CORRUPTED = 16,
    PHY_RECV_INCOMPLETED = 17
};

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet Command{
 * 	int note;
 * }
 * </pre>
 */
class Command : public ::cPacket
{
  protected:
    int note_var;

  private:
    void copy(const Command& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Command&);

  public:
    Command(const char *name=NULL, int kind=0);
    Command(const Command& other);
    virtual ~Command();
    Command& operator=(const Command& other);
    virtual Command *dup() const {return new Command(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getNote() const;
    virtual void setNote(int note);
};

inline void doPacking(cCommBuffer *b, Command& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Command& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet Result{
 * 	int note;
 * }
 * </pre>
 */
class Result : public ::cPacket
{
  protected:
    int note_var;

  private:
    void copy(const Result& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Result&);

  public:
    Result(const char *name=NULL, int kind=0);
    Result(const Result& other);
    virtual ~Result();
    Result& operator=(const Result& other);
    virtual Result *dup() const {return new Result(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getNote() const;
    virtual void setNote(int note);
};

inline void doPacking(cCommBuffer *b, Result& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Result& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet Raw{
 *     
 *     int headerLength = 6;
 *     
 *     
 *     
 *     
 *     
 *     
 *     
 *     
 *     
 *     
 *     int maxPayloadLength = 127;
 * }
 * </pre>
 */
class Raw : public ::cPacket
{
  protected:
    int headerLength_var;
    int maxPayloadLength_var;

  private:
    void copy(const Raw& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Raw&);

  public:
    Raw(const char *name=NULL, int kind=0);
    Raw(const Raw& other);
    virtual ~Raw();
    Raw& operator=(const Raw& other);
    virtual Raw *dup() const {return new Raw(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getHeaderLength() const;
    virtual void setHeaderLength(int headerLength);
    virtual int getMaxPayloadLength() const;
    virtual void setMaxPayloadLength(int maxPayloadLength);
};

inline void doPacking(cCommBuffer *b, Raw& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Raw& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet Frame{
 *     int numberTransmission = 0; 
 *     int headerLength; 			
 *     
 *     
 * 	
 * 	
 * 	int 	frameType;        		    
 *   	int 	securityEnabled;  		    
 *   	int 	framePending;     			
 *   	bool 	ackRequired;      			
 *   	bool 	panIdCompression; 			
 * 	int 	reserved; 		     	    
 *   	int 	destinationAddressMode;     
 *   	int 	frameVersion;     		    
 *   	int 	sourceAddressMode;          
 *   	
 *   	
 *   	uint16_t frameCheckSequence;
 * }
 * </pre>
 */
class Frame : public ::cPacket
{
  protected:
    int numberTransmission_var;
    int headerLength_var;
    int frameType_var;
    int securityEnabled_var;
    int framePending_var;
    bool ackRequired_var;
    bool panIdCompression_var;
    int reserved_var;
    int destinationAddressMode_var;
    int frameVersion_var;
    int sourceAddressMode_var;
    uint16_t frameCheckSequence_var;

  private:
    void copy(const Frame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Frame&);

  public:
    Frame(const char *name=NULL, int kind=0);
    Frame(const Frame& other);
    virtual ~Frame();
    Frame& operator=(const Frame& other);
    virtual Frame *dup() const {return new Frame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getNumberTransmission() const;
    virtual void setNumberTransmission(int numberTransmission);
    virtual int getHeaderLength() const;
    virtual void setHeaderLength(int headerLength);
    virtual int getFrameType() const;
    virtual void setFrameType(int frameType);
    virtual int getSecurityEnabled() const;
    virtual void setSecurityEnabled(int securityEnabled);
    virtual int getFramePending() const;
    virtual void setFramePending(int framePending);
    virtual bool getAckRequired() const;
    virtual void setAckRequired(bool ackRequired);
    virtual bool getPanIdCompression() const;
    virtual void setPanIdCompression(bool panIdCompression);
    virtual int getReserved() const;
    virtual void setReserved(int reserved);
    virtual int getDestinationAddressMode() const;
    virtual void setDestinationAddressMode(int destinationAddressMode);
    virtual int getFrameVersion() const;
    virtual void setFrameVersion(int frameVersion);
    virtual int getSourceAddressMode() const;
    virtual void setSourceAddressMode(int sourceAddressMode);
    virtual uint16_t getFrameCheckSequence() const;
    virtual void setFrameCheckSequence(uint16_t frameCheckSequence);
};

inline void doPacking(cCommBuffer *b, Frame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Frame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet FrameDataStandard extends Frame{
 * 
 *    	headerLength = 25; 
 *     
 *   	int dataSequenceNumber;	
 *   	
 * 	int sourcePanID;	  		
 * 	int destinationPanID; 		
 * 	int sourceMacAddress; 		
 * 	int destinationMacAddress;  
 * }
 * </pre>
 */
class FrameDataStandard : public ::wsn_energy::Frame
{
  protected:
    int dataSequenceNumber_var;
    int sourcePanID_var;
    int destinationPanID_var;
    int sourceMacAddress_var;
    int destinationMacAddress_var;

  private:
    void copy(const FrameDataStandard& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FrameDataStandard&);

  public:
    FrameDataStandard(const char *name=NULL, int kind=0);
    FrameDataStandard(const FrameDataStandard& other);
    virtual ~FrameDataStandard();
    FrameDataStandard& operator=(const FrameDataStandard& other);
    virtual FrameDataStandard *dup() const {return new FrameDataStandard(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getDataSequenceNumber() const;
    virtual void setDataSequenceNumber(int dataSequenceNumber);
    virtual int getSourcePanID() const;
    virtual void setSourcePanID(int sourcePanID);
    virtual int getDestinationPanID() const;
    virtual void setDestinationPanID(int destinationPanID);
    virtual int getSourceMacAddress() const;
    virtual void setSourceMacAddress(int sourceMacAddress);
    virtual int getDestinationMacAddress() const;
    virtual void setDestinationMacAddress(int destinationMacAddress);
};

inline void doPacking(cCommBuffer *b, FrameDataStandard& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, FrameDataStandard& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet FrameDataCompressed extends Frame{
 * 
 * 	 int headerLength = 32;
 * 	
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * }
 * </pre>
 */
class FrameDataCompressed : public ::wsn_energy::Frame
{
  protected:
    int headerLength_var;

  private:
    void copy(const FrameDataCompressed& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FrameDataCompressed&);

  public:
    FrameDataCompressed(const char *name=NULL, int kind=0);
    FrameDataCompressed(const FrameDataCompressed& other);
    virtual ~FrameDataCompressed();
    FrameDataCompressed& operator=(const FrameDataCompressed& other);
    virtual FrameDataCompressed *dup() const {return new FrameDataCompressed(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getHeaderLength() const;
    virtual void setHeaderLength(int headerLength);
};

inline void doPacking(cCommBuffer *b, FrameDataCompressed& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, FrameDataCompressed& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet FrameACK extends Frame{
 * 	headerLength = 3; 
 * 
 *    	int dataSequenceNumber;          	
 * }
 * </pre>
 */
class FrameACK : public ::wsn_energy::Frame
{
  protected:
    int dataSequenceNumber_var;

  private:
    void copy(const FrameACK& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FrameACK&);

  public:
    FrameACK(const char *name=NULL, int kind=0);
    FrameACK(const FrameACK& other);
    virtual ~FrameACK();
    FrameACK& operator=(const FrameACK& other);
    virtual FrameACK *dup() const {return new FrameACK(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getDataSequenceNumber() const;
    virtual void setDataSequenceNumber(int dataSequenceNumber);
};

inline void doPacking(cCommBuffer *b, FrameACK& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, FrameACK& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet FrameBeacon extends Frame{
 * 	headerLength = 26;
 *     
 * 	int beaconSequenceNumber;	
 * 	
 * 	int sourcePanID;	  		
 * 	int destinationPanID; 		
 * 	int sourceMacAddress; 		
 * 	int destinationMacAddress;  
 *   	
 *   	
 *   	int beaconOrder;			
 *   	int superFrameOrder;		
 *   	int finalCAPslot;			
 *   	int batteryLifeExtension;	
 *   	int reserved;				
 *   	int PANcoordinator;			
 *   	int associationPermit;		
 * 
 * 	
 * 	
 * 	
 * }
 * </pre>
 */
class FrameBeacon : public ::wsn_energy::Frame
{
  protected:
    int beaconSequenceNumber_var;
    int sourcePanID_var;
    int destinationPanID_var;
    int sourceMacAddress_var;
    int destinationMacAddress_var;
    int beaconOrder_var;
    int superFrameOrder_var;
    int finalCAPslot_var;
    int batteryLifeExtension_var;
    int reserved_var;
    int PANcoordinator_var;
    int associationPermit_var;

  private:
    void copy(const FrameBeacon& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FrameBeacon&);

  public:
    FrameBeacon(const char *name=NULL, int kind=0);
    FrameBeacon(const FrameBeacon& other);
    virtual ~FrameBeacon();
    FrameBeacon& operator=(const FrameBeacon& other);
    virtual FrameBeacon *dup() const {return new FrameBeacon(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getBeaconSequenceNumber() const;
    virtual void setBeaconSequenceNumber(int beaconSequenceNumber);
    virtual int getSourcePanID() const;
    virtual void setSourcePanID(int sourcePanID);
    virtual int getDestinationPanID() const;
    virtual void setDestinationPanID(int destinationPanID);
    virtual int getSourceMacAddress() const;
    virtual void setSourceMacAddress(int sourceMacAddress);
    virtual int getDestinationMacAddress() const;
    virtual void setDestinationMacAddress(int destinationMacAddress);
    virtual int getBeaconOrder() const;
    virtual void setBeaconOrder(int beaconOrder);
    virtual int getSuperFrameOrder() const;
    virtual void setSuperFrameOrder(int superFrameOrder);
    virtual int getFinalCAPslot() const;
    virtual void setFinalCAPslot(int finalCAPslot);
    virtual int getBatteryLifeExtension() const;
    virtual void setBatteryLifeExtension(int batteryLifeExtension);
    virtual int getReserved() const;
    virtual void setReserved(int reserved);
    virtual int getPANcoordinator() const;
    virtual void setPANcoordinator(int PANcoordinator);
    virtual int getAssociationPermit() const;
    virtual void setAssociationPermit(int associationPermit);
};

inline void doPacking(cCommBuffer *b, FrameBeacon& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, FrameBeacon& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet FrameCommand extends Frame{
 *     headerLength = 25;
 *     
 * 	int dataSequenceNumber;	
 * 	
 * 	int sourcePanID;	  		
 * 	int destinationPanID; 		
 * 	int sourceMacAddress; 		
 * 	int destinationMacAddress;  
 *   	
 *   	
 *   	int commandType; 
 * 
 * 	
 * 	
 * 	
 * 	
 * 	
 * 	
 * 	
 * 	
 * 	
 * 
 * 	
 * }
 * </pre>
 */
class FrameCommand : public ::wsn_energy::Frame
{
  protected:
    int dataSequenceNumber_var;
    int sourcePanID_var;
    int destinationPanID_var;
    int sourceMacAddress_var;
    int destinationMacAddress_var;
    int commandType_var;

  private:
    void copy(const FrameCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FrameCommand&);

  public:
    FrameCommand(const char *name=NULL, int kind=0);
    FrameCommand(const FrameCommand& other);
    virtual ~FrameCommand();
    FrameCommand& operator=(const FrameCommand& other);
    virtual FrameCommand *dup() const {return new FrameCommand(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getDataSequenceNumber() const;
    virtual void setDataSequenceNumber(int dataSequenceNumber);
    virtual int getSourcePanID() const;
    virtual void setSourcePanID(int sourcePanID);
    virtual int getDestinationPanID() const;
    virtual void setDestinationPanID(int destinationPanID);
    virtual int getSourceMacAddress() const;
    virtual void setSourceMacAddress(int sourceMacAddress);
    virtual int getDestinationMacAddress() const;
    virtual void setDestinationMacAddress(int destinationMacAddress);
    virtual int getCommandType() const;
    virtual void setCommandType(int commandType);
};

inline void doPacking(cCommBuffer *b, FrameCommand& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, FrameCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet IpPacketInterface{
 *     double time;  			
 *     int 	headerLength; 	
 * }
 * </pre>
 */
class IpPacketInterface : public ::cPacket
{
  protected:
    double time_var;
    int headerLength_var;

  private:
    void copy(const IpPacketInterface& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IpPacketInterface&);

  public:
    IpPacketInterface(const char *name=NULL, int kind=0);
    IpPacketInterface(const IpPacketInterface& other);
    virtual ~IpPacketInterface();
    IpPacketInterface& operator=(const IpPacketInterface& other);
    virtual IpPacketInterface *dup() const {return new IpPacketInterface(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual double getTime() const;
    virtual void setTime(double time);
    virtual int getHeaderLength() const;
    virtual void setHeaderLength(int headerLength);
};

inline void doPacking(cCommBuffer *b, IpPacketInterface& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IpPacketInterface& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet IpPacketStandard extends IpPacketInterface{  
 * 
 *     headerLength = 40;
 *     
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 *     
 *     int version;
 *     int trafficClass;
 *     int flowLabel;
 *     int payloadLength;
 *     int nextHeader; 
 *     int hopLimit;
 *     int sourceIpAddress;
 *     int destinationIpAddress;
 * }
 * </pre>
 */
class IpPacketStandard : public ::wsn_energy::IpPacketInterface
{
  protected:
    int version_var;
    int trafficClass_var;
    int flowLabel_var;
    int payloadLength_var;
    int nextHeader_var;
    int hopLimit_var;
    int sourceIpAddress_var;
    int destinationIpAddress_var;

  private:
    void copy(const IpPacketStandard& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IpPacketStandard&);

  public:
    IpPacketStandard(const char *name=NULL, int kind=0);
    IpPacketStandard(const IpPacketStandard& other);
    virtual ~IpPacketStandard();
    IpPacketStandard& operator=(const IpPacketStandard& other);
    virtual IpPacketStandard *dup() const {return new IpPacketStandard(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual int getTrafficClass() const;
    virtual void setTrafficClass(int trafficClass);
    virtual int getFlowLabel() const;
    virtual void setFlowLabel(int flowLabel);
    virtual int getPayloadLength() const;
    virtual void setPayloadLength(int payloadLength);
    virtual int getNextHeader() const;
    virtual void setNextHeader(int nextHeader);
    virtual int getHopLimit() const;
    virtual void setHopLimit(int hopLimit);
    virtual int getSourceIpAddress() const;
    virtual void setSourceIpAddress(int sourceIpAddress);
    virtual int getDestinationIpAddress() const;
    virtual void setDestinationIpAddress(int destinationIpAddress);
};

inline void doPacking(cCommBuffer *b, IpPacketStandard& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IpPacketStandard& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet IpPacketCompressed extends IpPacketInterface{
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 	
 * 	headerLength = 2;
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 	int sourceIPAddress; 			
 * 	int destinationIPAddress; 		
 * 	int trafficClassAndFlowLabel; 	
 * 	int nextHeader;					
 * 	int hc2encoding;				
 * }
 * </pre>
 */
class IpPacketCompressed : public ::wsn_energy::IpPacketInterface
{
  protected:
    int sourceIPAddress_var;
    int destinationIPAddress_var;
    int trafficClassAndFlowLabel_var;
    int nextHeader_var;
    int hc2encoding_var;

  private:
    void copy(const IpPacketCompressed& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IpPacketCompressed&);

  public:
    IpPacketCompressed(const char *name=NULL, int kind=0);
    IpPacketCompressed(const IpPacketCompressed& other);
    virtual ~IpPacketCompressed();
    IpPacketCompressed& operator=(const IpPacketCompressed& other);
    virtual IpPacketCompressed *dup() const {return new IpPacketCompressed(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSourceIPAddress() const;
    virtual void setSourceIPAddress(int sourceIPAddress);
    virtual int getDestinationIPAddress() const;
    virtual void setDestinationIPAddress(int destinationIPAddress);
    virtual int getTrafficClassAndFlowLabel() const;
    virtual void setTrafficClassAndFlowLabel(int trafficClassAndFlowLabel);
    virtual int getNextHeader() const;
    virtual void setNextHeader(int nextHeader);
    virtual int getHc2encoding() const;
    virtual void setHc2encoding(int hc2encoding);
};

inline void doPacking(cCommBuffer *b, IpPacketCompressed& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IpPacketCompressed& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet IcmpPacket{
 * 	
 * 	int headerLength = 8;
 * 	
 * 	
 * 	
 * 	
 * 	
 * 	
 * 	int type; 
 * 	int code; 
 * 	int checksum; 
 * 	int others;
 * }
 * </pre>
 */
class IcmpPacket : public ::cPacket
{
  protected:
    int headerLength_var;
    int type_var;
    int code_var;
    int checksum_var;
    int others_var;

  private:
    void copy(const IcmpPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IcmpPacket&);

  public:
    IcmpPacket(const char *name=NULL, int kind=0);
    IcmpPacket(const IcmpPacket& other);
    virtual ~IcmpPacket();
    IcmpPacket& operator=(const IcmpPacket& other);
    virtual IcmpPacket *dup() const {return new IcmpPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getHeaderLength() const;
    virtual void setHeaderLength(int headerLength);
    virtual int getType() const;
    virtual void setType(int type);
    virtual int getCode() const;
    virtual void setCode(int code);
    virtual int getChecksum() const;
    virtual void setChecksum(int checksum);
    virtual int getOthers() const;
    virtual void setOthers(int others);
};

inline void doPacking(cCommBuffer *b, IcmpPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IcmpPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet DIO{
 *     
 * 	int dodagID; 
 * 	int version; 
 * 	
 * 	unsigned long rank; 
 * 	
 * 	double selfEnergy;   
 * 	
 * 	
 * 	int payloadLength = 25;
 * }
 * </pre>
 */
class DIO : public ::cPacket
{
  protected:
    int dodagID_var;
    int version_var;
    unsigned long rank_var;
    double selfEnergy_var;
    int payloadLength_var;

  private:
    void copy(const DIO& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DIO&);

  public:
    DIO(const char *name=NULL, int kind=0);
    DIO(const DIO& other);
    virtual ~DIO();
    DIO& operator=(const DIO& other);
    virtual DIO *dup() const {return new DIO(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getDodagID() const;
    virtual void setDodagID(int dodagID);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual unsigned long getRank() const;
    virtual void setRank(unsigned long rank);
    virtual double getSelfEnergy() const;
    virtual void setSelfEnergy(double selfEnergy);
    virtual int getPayloadLength() const;
    virtual void setPayloadLength(int payloadLength);
};

inline void doPacking(cCommBuffer *b, DIO& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DIO& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet DIS{
 * 	
 * 	int payloadLength = 1;
 * }
 * </pre>
 */
class DIS : public ::cPacket
{
  protected:
    int payloadLength_var;

  private:
    void copy(const DIS& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DIS&);

  public:
    DIS(const char *name=NULL, int kind=0);
    DIS(const DIS& other);
    virtual ~DIS();
    DIS& operator=(const DIS& other);
    virtual DIS *dup() const {return new DIS(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getPayloadLength() const;
    virtual void setPayloadLength(int payloadLength);
};

inline void doPacking(cCommBuffer *b, DIS& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DIS& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet UdpPacketInterface{
 *     int headerLength; 
 * }
 * </pre>
 */
class UdpPacketInterface : public ::cPacket
{
  protected:
    int headerLength_var;

  private:
    void copy(const UdpPacketInterface& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpPacketInterface&);

  public:
    UdpPacketInterface(const char *name=NULL, int kind=0);
    UdpPacketInterface(const UdpPacketInterface& other);
    virtual ~UdpPacketInterface();
    UdpPacketInterface& operator=(const UdpPacketInterface& other);
    virtual UdpPacketInterface *dup() const {return new UdpPacketInterface(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getHeaderLength() const;
    virtual void setHeaderLength(int headerLength);
};

inline void doPacking(cCommBuffer *b, UdpPacketInterface& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UdpPacketInterface& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet UdpPacketStandard extends UdpPacketInterface{
 * 
 * 
 * 	headerLength = 8;  
 * 
 * 	short sourcePort;      
 * 	short destinationPort; 
 * 	short length;          
 * 	short checksum;        
 * }
 * </pre>
 */
class UdpPacketStandard : public ::wsn_energy::UdpPacketInterface
{
  protected:
    short sourcePort_var;
    short destinationPort_var;
    short length_var;
    short checksum_var;

  private:
    void copy(const UdpPacketStandard& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpPacketStandard&);

  public:
    UdpPacketStandard(const char *name=NULL, int kind=0);
    UdpPacketStandard(const UdpPacketStandard& other);
    virtual ~UdpPacketStandard();
    UdpPacketStandard& operator=(const UdpPacketStandard& other);
    virtual UdpPacketStandard *dup() const {return new UdpPacketStandard(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual short getSourcePort() const;
    virtual void setSourcePort(short sourcePort);
    virtual short getDestinationPort() const;
    virtual void setDestinationPort(short destinationPort);
    virtual short getLength() const;
    virtual void setLength(short length);
    virtual short getChecksum() const;
    virtual void setChecksum(short checksum);
};

inline void doPacking(cCommBuffer *b, UdpPacketStandard& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UdpPacketStandard& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet UdpPacketCompressed extends UdpPacketInterface{
 * 
 * 
 * 	headerLength = 3; 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 	
 * 	bool udpSourcePort;			
 * 	bool udpDestinationPort;	
 * 	short length;				
 * 	short checksum; 			
 * }
 * </pre>
 */
class UdpPacketCompressed : public ::wsn_energy::UdpPacketInterface
{
  protected:
    bool udpSourcePort_var;
    bool udpDestinationPort_var;
    short length_var;
    short checksum_var;

  private:
    void copy(const UdpPacketCompressed& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpPacketCompressed&);

  public:
    UdpPacketCompressed(const char *name=NULL, int kind=0);
    UdpPacketCompressed(const UdpPacketCompressed& other);
    virtual ~UdpPacketCompressed();
    UdpPacketCompressed& operator=(const UdpPacketCompressed& other);
    virtual UdpPacketCompressed *dup() const {return new UdpPacketCompressed(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getUdpSourcePort() const;
    virtual void setUdpSourcePort(bool udpSourcePort);
    virtual bool getUdpDestinationPort() const;
    virtual void setUdpDestinationPort(bool udpDestinationPort);
    virtual short getLength() const;
    virtual void setLength(short length);
    virtual short getChecksum() const;
    virtual void setChecksum(short checksum);
};

inline void doPacking(cCommBuffer *b, UdpPacketCompressed& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UdpPacketCompressed& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet Data{
 *     double time;  		
 *     
 *     int destinationPort; 	  
 *     int destinationIPAddress; 
 *     
 * 	string value; 		
 * }
 * </pre>
 */
class Data : public ::cPacket
{
  protected:
    double time_var;
    int destinationPort_var;
    int destinationIPAddress_var;
    opp_string value_var;

  private:
    void copy(const Data& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Data&);

  public:
    Data(const char *name=NULL, int kind=0);
    Data(const Data& other);
    virtual ~Data();
    Data& operator=(const Data& other);
    virtual Data *dup() const {return new Data(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual double getTime() const;
    virtual void setTime(double time);
    virtual int getDestinationPort() const;
    virtual void setDestinationPort(int destinationPort);
    virtual int getDestinationIPAddress() const;
    virtual void setDestinationIPAddress(int destinationIPAddress);
    virtual const char * getValue() const;
    virtual void setValue(const char * value);
};

inline void doPacking(cCommBuffer *b, Data& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Data& obj) {obj.parsimUnpack(b);}

}; // end namespace wsn_energy

#endif // _PACKET_M_H_

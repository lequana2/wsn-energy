//
// Generated file, do not edit! Created by opp_msgc 4.4 from package/packet/packet.msg.
//

#ifndef _PACKET_M_H_
#define _PACKET_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0404
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include <ipAddress.h>
// }}


namespace wsn_energy {

/**
 * Enum generated from <tt>package/packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum IP_PACKET_NEXT_HEADER{
 *     NEXT_HEADER_UDP		= 0; 
 *     NEXT_HEADER_TCP		= 1; 
 *     NEXT_HEADER_ICMP	= 2; 
 * };
 * </pre>
 */
enum IP_PACKET_NEXT_HEADER {
    NEXT_HEADER_UDP = 0,
    NEXT_HEADER_TCP = 1,
    NEXT_HEADER_ICMP = 2
};

/**
 * Enum generated from <tt>package/packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum ICMP_TYPE{
 *     ICMP_RPL		= 155; 
 * }
 * </pre>
 */
enum ICMP_TYPE {
    ICMP_RPL = 155
};

/**
 * Enum generated from <tt>package/packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * enum ICMP_CODE{
 * 	RPL_DIO_CODE   	  = 0;	
 * 	RPL_DIS_CODE	  = 1;	
 * }
 * </pre>
 */
enum ICMP_CODE {
    RPL_DIO_CODE = 0,
    RPL_DIS_CODE = 1
};

/**
 * Class generated from <tt>package/packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet IpPacketInterface{
 *     double time;  			
 *     int 	headerLength; 	
 * }
 * </pre>
 */
class IpPacketInterface : public ::cPacket
{
  protected:
    double time_var;
    int headerLength_var;

  private:
    void copy(const IpPacketInterface& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IpPacketInterface&);

  public:
    IpPacketInterface(const char *name=NULL, int kind=0);
    IpPacketInterface(const IpPacketInterface& other);
    virtual ~IpPacketInterface();
    IpPacketInterface& operator=(const IpPacketInterface& other);
    virtual IpPacketInterface *dup() const {return new IpPacketInterface(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual double getTime() const;
    virtual void setTime(double time);
    virtual int getHeaderLength() const;
    virtual void setHeaderLength(int headerLength);
};

inline void doPacking(cCommBuffer *b, IpPacketInterface& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IpPacketInterface& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet IpPacketStandard extends IpPacketInterface{  
 * 
 *     headerLength = 40;
 *     
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 *     
 *     int version;
 *     int trafficClass;
 *     int flowLabel;
 *     int payloadLength;
 *     int nextHeader; 
 *     int hopLimit;
 *     IpAddress sourceIpAddressV6;
 *     IpAddress destinationIpAddressV6;
 *     
 *     int sourceIpAddress;
 *     int destinationIpAddress;
 * }
 * </pre>
 */
class IpPacketStandard : public ::wsn_energy::IpPacketInterface
{
  protected:
    int version_var;
    int trafficClass_var;
    int flowLabel_var;
    int payloadLength_var;
    int nextHeader_var;
    int hopLimit_var;
    IpAddress sourceIpAddressV6_var;
    IpAddress destinationIpAddressV6_var;
    int sourceIpAddress_var;
    int destinationIpAddress_var;

  private:
    void copy(const IpPacketStandard& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IpPacketStandard&);

  public:
    IpPacketStandard(const char *name=NULL, int kind=0);
    IpPacketStandard(const IpPacketStandard& other);
    virtual ~IpPacketStandard();
    IpPacketStandard& operator=(const IpPacketStandard& other);
    virtual IpPacketStandard *dup() const {return new IpPacketStandard(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual int getTrafficClass() const;
    virtual void setTrafficClass(int trafficClass);
    virtual int getFlowLabel() const;
    virtual void setFlowLabel(int flowLabel);
    virtual int getPayloadLength() const;
    virtual void setPayloadLength(int payloadLength);
    virtual int getNextHeader() const;
    virtual void setNextHeader(int nextHeader);
    virtual int getHopLimit() const;
    virtual void setHopLimit(int hopLimit);
    virtual IpAddress& getSourceIpAddressV6();
    virtual const IpAddress& getSourceIpAddressV6() const {return const_cast<IpPacketStandard*>(this)->getSourceIpAddressV6();}
    virtual void setSourceIpAddressV6(const IpAddress& sourceIpAddressV6);
    virtual IpAddress& getDestinationIpAddressV6();
    virtual const IpAddress& getDestinationIpAddressV6() const {return const_cast<IpPacketStandard*>(this)->getDestinationIpAddressV6();}
    virtual void setDestinationIpAddressV6(const IpAddress& destinationIpAddressV6);
    virtual int getSourceIpAddress() const;
    virtual void setSourceIpAddress(int sourceIpAddress);
    virtual int getDestinationIpAddress() const;
    virtual void setDestinationIpAddress(int destinationIpAddress);
};

inline void doPacking(cCommBuffer *b, IpPacketStandard& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IpPacketStandard& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet IpPacketCompressed extends IpPacketInterface{
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 	
 * 	headerLength = 2;
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 	int sourceIpAddress; 			
 * 	int destinationIpAddress; 		
 * 	int trafficClassAndFlowLabel; 	
 * 	int nextHeader;					
 * 	int hc2encoding;				
 * 	
 * 	int hopLimit; 					
 * 	
 * 	int metaHopLimit;			  
 * 	IpAddress metaSourceIpAddressV6;	    
 * 	IpAddress metaDestinationIpAddressV6; 
 * 	
 * 	int metaSourceIpAddress;	    
 * 	int  metaDestinationIpAddress; 
 * }
 * </pre>
 */
class IpPacketCompressed : public ::wsn_energy::IpPacketInterface
{
  protected:
    int sourceIpAddress_var;
    int destinationIpAddress_var;
    int trafficClassAndFlowLabel_var;
    int nextHeader_var;
    int hc2encoding_var;
    int hopLimit_var;
    int metaHopLimit_var;
    IpAddress metaSourceIpAddressV6_var;
    IpAddress metaDestinationIpAddressV6_var;
    int metaSourceIpAddress_var;
    int metaDestinationIpAddress_var;

  private:
    void copy(const IpPacketCompressed& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IpPacketCompressed&);

  public:
    IpPacketCompressed(const char *name=NULL, int kind=0);
    IpPacketCompressed(const IpPacketCompressed& other);
    virtual ~IpPacketCompressed();
    IpPacketCompressed& operator=(const IpPacketCompressed& other);
    virtual IpPacketCompressed *dup() const {return new IpPacketCompressed(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSourceIpAddress() const;
    virtual void setSourceIpAddress(int sourceIpAddress);
    virtual int getDestinationIpAddress() const;
    virtual void setDestinationIpAddress(int destinationIpAddress);
    virtual int getTrafficClassAndFlowLabel() const;
    virtual void setTrafficClassAndFlowLabel(int trafficClassAndFlowLabel);
    virtual int getNextHeader() const;
    virtual void setNextHeader(int nextHeader);
    virtual int getHc2encoding() const;
    virtual void setHc2encoding(int hc2encoding);
    virtual int getHopLimit() const;
    virtual void setHopLimit(int hopLimit);
    virtual int getMetaHopLimit() const;
    virtual void setMetaHopLimit(int metaHopLimit);
    virtual IpAddress& getMetaSourceIpAddressV6();
    virtual const IpAddress& getMetaSourceIpAddressV6() const {return const_cast<IpPacketCompressed*>(this)->getMetaSourceIpAddressV6();}
    virtual void setMetaSourceIpAddressV6(const IpAddress& metaSourceIpAddressV6);
    virtual IpAddress& getMetaDestinationIpAddressV6();
    virtual const IpAddress& getMetaDestinationIpAddressV6() const {return const_cast<IpPacketCompressed*>(this)->getMetaDestinationIpAddressV6();}
    virtual void setMetaDestinationIpAddressV6(const IpAddress& metaDestinationIpAddressV6);
    virtual int getMetaSourceIpAddress() const;
    virtual void setMetaSourceIpAddress(int metaSourceIpAddress);
    virtual int getMetaDestinationIpAddress() const;
    virtual void setMetaDestinationIpAddress(int metaDestinationIpAddress);
};

inline void doPacking(cCommBuffer *b, IpPacketCompressed& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IpPacketCompressed& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet IcmpPacket{
 * 	
 * 	int headerLength = 8;
 * 	
 * 	
 * 	
 * 	
 * 	
 * 	
 * 	int type; 
 * 	int code; 
 * 	int checksum; 
 * 	int others;
 * }
 * </pre>
 */
class IcmpPacket : public ::cPacket
{
  protected:
    int headerLength_var;
    int type_var;
    int code_var;
    int checksum_var;
    int others_var;

  private:
    void copy(const IcmpPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IcmpPacket&);

  public:
    IcmpPacket(const char *name=NULL, int kind=0);
    IcmpPacket(const IcmpPacket& other);
    virtual ~IcmpPacket();
    IcmpPacket& operator=(const IcmpPacket& other);
    virtual IcmpPacket *dup() const {return new IcmpPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getHeaderLength() const;
    virtual void setHeaderLength(int headerLength);
    virtual int getType() const;
    virtual void setType(int type);
    virtual int getCode() const;
    virtual void setCode(int code);
    virtual int getChecksum() const;
    virtual void setChecksum(int checksum);
    virtual int getOthers() const;
    virtual void setOthers(int others);
};

inline void doPacking(cCommBuffer *b, IcmpPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IcmpPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet DIO{
 *     int senderID; 
 * 	int payloadLength = 24; 
 *     
 * 	int instanceID;
 * 	int version; 
 * 	double rank; 
 * 	bool grounded;
 * 	bool o;
 * 	int modeOfOperation;
 * 	int preference;
 * 	int dstn;
 * 	int flags;
 * 	int reserved;
 * 	int dodagID; 
 * }
 * </pre>
 */
class DIO : public ::cPacket
{
  protected:
    int senderID_var;
    int payloadLength_var;
    int instanceID_var;
    int version_var;
    double rank_var;
    bool grounded_var;
    bool o_var;
    int modeOfOperation_var;
    int preference_var;
    int dstn_var;
    int flags_var;
    int reserved_var;
    int dodagID_var;

  private:
    void copy(const DIO& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DIO&);

  public:
    DIO(const char *name=NULL, int kind=0);
    DIO(const DIO& other);
    virtual ~DIO();
    DIO& operator=(const DIO& other);
    virtual DIO *dup() const {return new DIO(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSenderID() const;
    virtual void setSenderID(int senderID);
    virtual int getPayloadLength() const;
    virtual void setPayloadLength(int payloadLength);
    virtual int getInstanceID() const;
    virtual void setInstanceID(int instanceID);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual double getRank() const;
    virtual void setRank(double rank);
    virtual bool getGrounded() const;
    virtual void setGrounded(bool grounded);
    virtual bool getO() const;
    virtual void setO(bool o);
    virtual int getModeOfOperation() const;
    virtual void setModeOfOperation(int modeOfOperation);
    virtual int getPreference() const;
    virtual void setPreference(int preference);
    virtual int getDstn() const;
    virtual void setDstn(int dstn);
    virtual int getFlags() const;
    virtual void setFlags(int flags);
    virtual int getReserved() const;
    virtual void setReserved(int reserved);
    virtual int getDodagID() const;
    virtual void setDodagID(int dodagID);
};

inline void doPacking(cCommBuffer *b, DIO& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DIO& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet DIS{
 * 	int payloadLength = 2; 
 * 	
 * 	
 * 	
 * 	
 * 	int flag;
 * 	int reserved;
 * }
 * </pre>
 */
class DIS : public ::cPacket
{
  protected:
    int payloadLength_var;
    int flag_var;
    int reserved_var;

  private:
    void copy(const DIS& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DIS&);

  public:
    DIS(const char *name=NULL, int kind=0);
    DIS(const DIS& other);
    virtual ~DIS();
    DIS& operator=(const DIS& other);
    virtual DIS *dup() const {return new DIS(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getPayloadLength() const;
    virtual void setPayloadLength(int payloadLength);
    virtual int getFlag() const;
    virtual void setFlag(int flag);
    virtual int getReserved() const;
    virtual void setReserved(int reserved);
};

inline void doPacking(cCommBuffer *b, DIS& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DIS& obj) {obj.parsimUnpack(b);}

}; // end namespace wsn_energy

#endif // _PACKET_M_H_

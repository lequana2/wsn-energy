//
// Generated file, do not edit! Created by opp_msgc 4.4 from package/packet/packet.msg.
//

#ifndef _PACKET_M_H_
#define _PACKET_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0404
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif


namespace wsn_energy {

/**
 * Class generated from <tt>package/packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet IpPacketInterface{
 *     double time;  			
 *     int 	headerLength; 	
 * }
 * </pre>
 */
class IpPacketInterface : public ::cPacket
{
  protected:
    double time_var;
    int headerLength_var;

  private:
    void copy(const IpPacketInterface& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IpPacketInterface&);

  public:
    IpPacketInterface(const char *name=NULL, int kind=0);
    IpPacketInterface(const IpPacketInterface& other);
    virtual ~IpPacketInterface();
    IpPacketInterface& operator=(const IpPacketInterface& other);
    virtual IpPacketInterface *dup() const {return new IpPacketInterface(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual double getTime() const;
    virtual void setTime(double time);
    virtual int getHeaderLength() const;
    virtual void setHeaderLength(int headerLength);
};

inline void doPacking(cCommBuffer *b, IpPacketInterface& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IpPacketInterface& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet IpPacketStandard extends IpPacketInterface{  
 * 
 *     headerLength = 40;
 *     
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 *     
 *     int version;
 *     int trafficClass;
 *     int flowLabel;
 *     int payloadLength;
 *     int nextHeader; 
 *     int hopLimit;
 *     int sourceIpAddress;
 *     int destinationIpAddress;
 * }
 * </pre>
 */
class IpPacketStandard : public ::wsn_energy::IpPacketInterface
{
  protected:
    int version_var;
    int trafficClass_var;
    int flowLabel_var;
    int payloadLength_var;
    int nextHeader_var;
    int hopLimit_var;
    int sourceIpAddress_var;
    int destinationIpAddress_var;

  private:
    void copy(const IpPacketStandard& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IpPacketStandard&);

  public:
    IpPacketStandard(const char *name=NULL, int kind=0);
    IpPacketStandard(const IpPacketStandard& other);
    virtual ~IpPacketStandard();
    IpPacketStandard& operator=(const IpPacketStandard& other);
    virtual IpPacketStandard *dup() const {return new IpPacketStandard(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual int getTrafficClass() const;
    virtual void setTrafficClass(int trafficClass);
    virtual int getFlowLabel() const;
    virtual void setFlowLabel(int flowLabel);
    virtual int getPayloadLength() const;
    virtual void setPayloadLength(int payloadLength);
    virtual int getNextHeader() const;
    virtual void setNextHeader(int nextHeader);
    virtual int getHopLimit() const;
    virtual void setHopLimit(int hopLimit);
    virtual int getSourceIpAddress() const;
    virtual void setSourceIpAddress(int sourceIpAddress);
    virtual int getDestinationIpAddress() const;
    virtual void setDestinationIpAddress(int destinationIpAddress);
};

inline void doPacking(cCommBuffer *b, IpPacketStandard& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IpPacketStandard& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet IpPacketCompressed extends IpPacketInterface{
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 	
 * 	headerLength = 2;
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 	int sourceIPAddress; 			
 * 	int destinationIPAddress; 		
 * 	int trafficClassAndFlowLabel; 	
 * 	int nextHeader;					
 * 	int hc2encoding;				
 * }
 * </pre>
 */
class IpPacketCompressed : public ::wsn_energy::IpPacketInterface
{
  protected:
    int sourceIPAddress_var;
    int destinationIPAddress_var;
    int trafficClassAndFlowLabel_var;
    int nextHeader_var;
    int hc2encoding_var;

  private:
    void copy(const IpPacketCompressed& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IpPacketCompressed&);

  public:
    IpPacketCompressed(const char *name=NULL, int kind=0);
    IpPacketCompressed(const IpPacketCompressed& other);
    virtual ~IpPacketCompressed();
    IpPacketCompressed& operator=(const IpPacketCompressed& other);
    virtual IpPacketCompressed *dup() const {return new IpPacketCompressed(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSourceIPAddress() const;
    virtual void setSourceIPAddress(int sourceIPAddress);
    virtual int getDestinationIPAddress() const;
    virtual void setDestinationIPAddress(int destinationIPAddress);
    virtual int getTrafficClassAndFlowLabel() const;
    virtual void setTrafficClassAndFlowLabel(int trafficClassAndFlowLabel);
    virtual int getNextHeader() const;
    virtual void setNextHeader(int nextHeader);
    virtual int getHc2encoding() const;
    virtual void setHc2encoding(int hc2encoding);
};

inline void doPacking(cCommBuffer *b, IpPacketCompressed& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IpPacketCompressed& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet IcmpPacket{
 * 	
 * 	int headerLength = 8;
 * 	
 * 	
 * 	
 * 	
 * 	
 * 	
 * 	int type; 
 * 	int code; 
 * 	int checksum; 
 * 	int others;
 * }
 * </pre>
 */
class IcmpPacket : public ::cPacket
{
  protected:
    int headerLength_var;
    int type_var;
    int code_var;
    int checksum_var;
    int others_var;

  private:
    void copy(const IcmpPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IcmpPacket&);

  public:
    IcmpPacket(const char *name=NULL, int kind=0);
    IcmpPacket(const IcmpPacket& other);
    virtual ~IcmpPacket();
    IcmpPacket& operator=(const IcmpPacket& other);
    virtual IcmpPacket *dup() const {return new IcmpPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getHeaderLength() const;
    virtual void setHeaderLength(int headerLength);
    virtual int getType() const;
    virtual void setType(int type);
    virtual int getCode() const;
    virtual void setCode(int code);
    virtual int getChecksum() const;
    virtual void setChecksum(int checksum);
    virtual int getOthers() const;
    virtual void setOthers(int others);
};

inline void doPacking(cCommBuffer *b, IcmpPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IcmpPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet DIO{
 *     
 * 	int dodagID; 
 * 	int version; 
 * 	
 * 	unsigned long rank; 
 * 	
 * 	double selfEnergy;   
 * 	
 * 	
 * 	int payloadLength = 25;
 * }
 * </pre>
 */
class DIO : public ::cPacket
{
  protected:
    int dodagID_var;
    int version_var;
    unsigned long rank_var;
    double selfEnergy_var;
    int payloadLength_var;

  private:
    void copy(const DIO& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DIO&);

  public:
    DIO(const char *name=NULL, int kind=0);
    DIO(const DIO& other);
    virtual ~DIO();
    DIO& operator=(const DIO& other);
    virtual DIO *dup() const {return new DIO(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getDodagID() const;
    virtual void setDodagID(int dodagID);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual unsigned long getRank() const;
    virtual void setRank(unsigned long rank);
    virtual double getSelfEnergy() const;
    virtual void setSelfEnergy(double selfEnergy);
    virtual int getPayloadLength() const;
    virtual void setPayloadLength(int payloadLength);
};

inline void doPacking(cCommBuffer *b, DIO& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DIO& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/packet/packet.msg</tt> by opp_msgc.
 * <pre>
 * packet DIS{
 * 	
 * 	int payloadLength = 1;
 * }
 * </pre>
 */
class DIS : public ::cPacket
{
  protected:
    int payloadLength_var;

  private:
    void copy(const DIS& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DIS&);

  public:
    DIS(const char *name=NULL, int kind=0);
    DIS(const DIS& other);
    virtual ~DIS();
    DIS& operator=(const DIS& other);
    virtual DIS *dup() const {return new DIS(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getPayloadLength() const;
    virtual void setPayloadLength(int payloadLength);
};

inline void doPacking(cCommBuffer *b, DIS& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DIS& obj) {obj.parsimUnpack(b);}

}; // end namespace wsn_energy

#endif // _PACKET_M_H_

//
// Generated file, do not edit! Created by opp_msgc 4.4 from package/strobe/strobe.msg.
//

#ifndef _STROBE_M_H_
#define _STROBE_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0404
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif


namespace wsn_energy {

/**
 * Enum generated from <tt>package/strobe/strobe.msg</tt> by opp_msgc.
 * <pre>
 * enum MESSAGE_KIND{
 * 	DATA    = 2; 
 * 	COMMAND = 4; 
 * 	RESULT  = 1; 
 * };
 * </pre>
 */
enum MESSAGE_KIND {
    DATA = 2,
    COMMAND = 4,
    RESULT = 1
};

/**
 * Enum generated from <tt>package/strobe/strobe.msg</tt> by opp_msgc.
 * <pre>
 * enum MANUAL_EVENT{
 * 	NODE_STARTUP  = 0; 
 * 	OUT_OF_ENERGY = 1; 
 * 	NODE_DESTRUCT = 2; 
 * };
 * </pre>
 */
enum MANUAL_EVENT {
    NODE_STARTUP = 0,
    OUT_OF_ENERGY = 1,
    NODE_DESTRUCT = 2
};

/**
 * Enum generated from <tt>package/strobe/strobe.msg</tt> by opp_msgc.
 * <pre>
 * enum COMMAND_APP{
 * 	APP_ENVIRON_FLAG = 2; 
 * 	APP_SENSING_FLAG = 1; 
 * 	APP_WORKING_FLAG = 0; 
 * 	
 * 	RPL_SET_UP_DELAY = 4; 
 * };
 * </pre>
 */
enum COMMAND_APP {
    APP_ENVIRON_FLAG = 2,
    APP_SENSING_FLAG = 1,
    APP_WORKING_FLAG = 0,
    RPL_SET_UP_DELAY = 4
};

/**
 * Enum generated from <tt>package/strobe/strobe.msg</tt> by opp_msgc.
 * <pre>
 * enum COMMAND_NET{
 *     NET_TIMER_DIO       = 1; 
 *     NET_TIMER_DIS       = 2; 
 * 	NET_CHECK_BUFFER    = 3; 
 * 
 * 	RPL_CONSTRUCT 	 	= 4; 
 * };
 * </pre>
 */
enum COMMAND_NET {
    NET_TIMER_DIO = 1,
    NET_TIMER_DIS = 2,
    NET_CHECK_BUFFER = 3,
    RPL_CONSTRUCT = 4
};

/**
 * Enum generated from <tt>package/strobe/strobe.msg</tt> by opp_msgc.
 * <pre>
 * enum RESULT_NET{
 * 	NET_DIO_SENT	= 23; 
 * 	NET_DIS_SENT    = 24; 
 * }
 * </pre>
 */
enum RESULT_NET {
    NET_DIO_SENT = 23,
    NET_DIS_SENT = 24
};

/**
 * Enum generated from <tt>package/strobe/strobe.msg</tt> by opp_msgc.
 * <pre>
 * enum IP_PACKET_NEXT_HEADER{
 *     NEXT_HEADER_UDP		= 0; 
 *     NEXT_HEADER_TCP		= 1; 
 *     NEXT_HEADER_ICMP	= 2; 
 * };
 * </pre>
 */
enum IP_PACKET_NEXT_HEADER {
    NEXT_HEADER_UDP = 0,
    NEXT_HEADER_TCP = 1,
    NEXT_HEADER_ICMP = 2
};

/**
 * Enum generated from <tt>package/strobe/strobe.msg</tt> by opp_msgc.
 * <pre>
 * enum ICMP_TYPE{
 *     ICMP_RPL		= 0; 
 * }
 * </pre>
 */
enum ICMP_TYPE {
    ICMP_RPL = 0
};

/**
 * Enum generated from <tt>package/strobe/strobe.msg</tt> by opp_msgc.
 * <pre>
 * enum ICMP_CODE{
 * 	RPL_DIO_CODE   	  = 0;	
 * 	RPL_DIS_CODE	  = 1;	
 * }
 * </pre>
 */
enum ICMP_CODE {
    RPL_DIO_CODE = 0,
    RPL_DIS_CODE = 1
};

/**
 * Enum generated from <tt>package/strobe/strobe.msg</tt> by opp_msgc.
 * <pre>
 * enum COMMAND_MAC{
 * 	CHANNEL_CCA_REQUEST = 70; 
 * 	FRAME_TRANS_REQUEST = 71; 
 * 	
 * 	MAC_BEGIN_SEND_FRAME = 73; 
 * 	MAC_END_SEND_FRAME   = 74; 
 * 	MAC_EXPIRE_IFS		 = 75; 
 * };
 * </pre>
 */
enum COMMAND_MAC {
    CHANNEL_CCA_REQUEST = 70,
    FRAME_TRANS_REQUEST = 71,
    MAC_BEGIN_SEND_FRAME = 73,
    MAC_END_SEND_FRAME = 74,
    MAC_EXPIRE_IFS = 75
};

/**
 * Enum generated from <tt>package/strobe/strobe.msg</tt> by opp_msgc.
 * <pre>
 * enum FRAME_TYPE{
 *     FRAME_BEACON  	= 35; 
 *     FRAME_COMMAND 	= 36; 
 * 	FRAME_DATA 		= 37; 
 * 	FRAME_ACK  		= 38; 
 * }
 * </pre>
 */
enum FRAME_TYPE {
    FRAME_BEACON = 35,
    FRAME_COMMAND = 36,
    FRAME_DATA = 37,
    FRAME_ACK = 38
};

/**
 * Enum generated from <tt>package/strobe/strobe.msg</tt> by opp_msgc.
 * <pre>
 * enum RESULT_FROM_MAC{
 *     MAC_SEND_DEAD_NEIGHBOR = 5;
 * 	
 * 	MAC_FINISH_PHASE       = 29; 
 * 	MAC_SEND_END_TRANSMIT  = 28; 
 * };
 * </pre>
 */
enum RESULT_FROM_MAC {
    MAC_SEND_DEAD_NEIGHBOR = 5,
    MAC_FINISH_PHASE = 29,
    MAC_SEND_END_TRANSMIT = 28
};

/**
 * Enum generated from <tt>package/strobe/strobe.msg</tt> by opp_msgc.
 * <pre>
 * enum COMMAND_RDC{
 * 	RDC_TRANSMIT = 30; 
 * 	RDC_LISTEN 	 = 31; 
 * 	RDC_IDLE     = 32; 
 * 	
 * 	RDC_WAIT_FOR_ACK  = 34; 
 * 	RDC_CHANNEL_CHECK = 35; 
 * };
 * </pre>
 */
enum COMMAND_RDC {
    RDC_TRANSMIT = 30,
    RDC_LISTEN = 31,
    RDC_IDLE = 32,
    RDC_WAIT_FOR_ACK = 34,
    RDC_CHANNEL_CHECK = 35
};

/**
 * Enum generated from <tt>package/strobe/strobe.msg</tt> by opp_msgc.
 * <pre>
 * enum RESULT_RDC{
 * 	RDC_SEND_OK     = 0; 
 * 	RDC_SEND_NO_ACK = 1; 
 * 	RDC_SEND_FATAL  = 2; 
 * 	RDC_SEND_COL	= 3; 
 * 
 * 	RDC_READY_TRANS_PHASE = 4; 
 * 	RDC_STOP_TRANS_PHASE  = 5; 
 * };
 * </pre>
 */
enum RESULT_RDC {
    RDC_SEND_OK = 0,
    RDC_SEND_NO_ACK = 1,
    RDC_SEND_FATAL = 2,
    RDC_SEND_COL = 3,
    RDC_READY_TRANS_PHASE = 4,
    RDC_STOP_TRANS_PHASE = 5
};

/**
 * Enum generated from <tt>package/strobe/strobe.msg</tt> by opp_msgc.
 * <pre>
 * enum COMMAND_PHY{
 * 	PHY_BEGIN_CCA       = 10; 
 * 	PHY_END_CCA         = 11; 
 * 	
 *  	PHY_SWITCH_TRANSMIT	= 12; 
 *  	PHY_SWITCH_LISTEN	= 13; 
 *  	PHY_SWITCH_IDLE     = 14; 
 *  	
 *  	PHY_BEGIN_TRANSMIT  = 15; 
 * 	PHY_END_TRANSMIT	= 16; 
 * 
 *  	PHY_LISTENING    = 17; 
 *  	
 *  	PHY_IDLING  	 = 18; 
 * };
 * </pre>
 */
enum COMMAND_PHY {
    PHY_BEGIN_CCA = 10,
    PHY_END_CCA = 11,
    PHY_SWITCH_TRANSMIT = 12,
    PHY_SWITCH_LISTEN = 13,
    PHY_SWITCH_IDLE = 14,
    PHY_BEGIN_TRANSMIT = 15,
    PHY_END_TRANSMIT = 16,
    PHY_LISTENING = 17,
    PHY_IDLING = 18
};

/**
 * Enum generated from <tt>package/strobe/strobe.msg</tt> by opp_msgc.
 * <pre>
 * enum RESULT_PHY{
 * 	CHANNEL_CLEAR   	= 10; 
 * 	CHANNEL_BUSY    	= 11; 
 * 	
 * 	PHY_TX_OK		 = 12; 
 * 	PHY_TX_ERR 		 = 13; 
 * 	PHY_BUSY		 = 14; 
 * 	
 * 	PHY_RECV_OK          = 15; 
 * 	PHY_RECV_CORRUPTED   = 16; 
 * 	PHY_RECV_INCOMPLETED = 17; 
 * };
 * </pre>
 */
enum RESULT_PHY {
    CHANNEL_CLEAR = 10,
    CHANNEL_BUSY = 11,
    PHY_TX_OK = 12,
    PHY_TX_ERR = 13,
    PHY_BUSY = 14,
    PHY_RECV_OK = 15,
    PHY_RECV_CORRUPTED = 16,
    PHY_RECV_INCOMPLETED = 17
};

/**
 * Class generated from <tt>package/strobe/strobe.msg</tt> by opp_msgc.
 * <pre>
 * packet Command{
 * 	int note;
 * }
 * </pre>
 */
class Command : public ::cPacket
{
  protected:
    int note_var;

  private:
    void copy(const Command& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Command&);

  public:
    Command(const char *name=NULL, int kind=0);
    Command(const Command& other);
    virtual ~Command();
    Command& operator=(const Command& other);
    virtual Command *dup() const {return new Command(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getNote() const;
    virtual void setNote(int note);
};

inline void doPacking(cCommBuffer *b, Command& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Command& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>package/strobe/strobe.msg</tt> by opp_msgc.
 * <pre>
 * packet Result{
 * 	int note;
 * }
 * </pre>
 */
class Result : public ::cPacket
{
  protected:
    int note_var;

  private:
    void copy(const Result& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Result&);

  public:
    Result(const char *name=NULL, int kind=0);
    Result(const Result& other);
    virtual ~Result();
    Result& operator=(const Result& other);
    virtual Result *dup() const {return new Result(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getNote() const;
    virtual void setNote(int note);
};

inline void doPacking(cCommBuffer *b, Result& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Result& obj) {obj.parsimUnpack(b);}

}; // end namespace wsn_energy

#endif // _STROBE_M_H_
